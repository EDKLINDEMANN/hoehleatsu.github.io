---
layout: post
title: "Happy pbirthday class of 2016"
tags: [rstats, stats, data journalism, onomastics]
bibliography: ~/Literature/Bibtex/jabref.bib
comments: true
---

```{r,include=FALSE,echo=FALSE,message=FALSE}
##If default fig.path, then set it.
if (knitr::opts_chunk$get("fig.path") == "figure/") {
  knitr::opts_knit$set( base.dir = '/Users/hoehle/Sandbox/Blog/')
  knitr::opts_chunk$set(fig.path="figure/source/2017-02-08-bday/")
}
fullFigPath <- paste0(knitr::opts_knit$get("base.dir"),knitr::opts_chunk$get("fig.path"))
filePath <- "/Users/hoehle/Sandbox/Blog/figure/source/2017-02-08-bday/"

knitr::opts_chunk$set(echo = TRUE,fig.width=8,fig.height=5,fig.cap='',fig.align='center',echo=FALSE) # autodep=TRUE
options(width=90)
library("dplyr")
library("ggplot2")
library("tidyr")
library("methods")
library("magrittr")

##For plotting the map
library("rgdal")
library("rgeos")

library("xtable")

##If you are unhappy about the colours, change them here
palette <- c(f="darkred",m="blue")

theme_set(theme_bw())
```

## Abstract

Continuing the analys of firstnames given to newborns in Berlin 2016,
we solve the following problem: what is the probability, that in a
school class of size $n$ of these 2016 born kids there will at least
two kids having the same first name. This problem is an instance of
the birthday problem with unequal probabilities. R code is provided
for solving the problem exactly for moderate $n$ and approximatively
for larger $n$. For the case that all probabilities are equal, our
results are compared to the output of R's lovely `pbirthday` function.

<center>
```{r,results='asis',echo=FALSE}
cat(paste0("![]({{ site.baseurl }}/",knitr::opts_chunk$get("fig.path"),"WORDMAPCLOUD-1.png"),")")
```
</center>

{% include license.html %}

## Introduction

In the post
[Naming Uncertainty by the Bootstrap](http://staff.math.su.se/hoehle/blog/2017/02/06/onomastics.html)
we performed a descriptive analysis of the names given to newborns in
Berlin 2016. For instance, it was shown that Marie and Alexander were
the top-1 names among girls and boys, respectively. In a comment
[Maëlle](http://www.masalmon.eu/) asked what's the resulting
probability that there will be kids with the same name in a school
class. We implement equations by @klotz1979 and @mase1992 in R in
order to answer this important question.

## The Birthday Problem

The above posed question is a variation of the
[**birthday problem**](https://en.wikipedia.org/wiki/Birthday_problem),
which every statistician has solved at least once in an introductory
probability class: *in a class of $n$ randomly chosen persons, what is
the probability that some pair of them will have the same birthday*?
Assuming that there are $N=365$ possible birthdays and all days are
equally probable the answer can be calculated as:

$$
P(\text{at least two people in the class have the same birthday}) =
1-\frac{(N)_{n}}{N^n},
$$

where $(x)_n = x! / (x-n)!$. Say we are
interested in $n=26$, which is the
[maximal allowed class size](https://www.berlin.de/imperia/md/content/sen-bildung/rechtsvorschriften/grundschulverordnung.pdf)
in Berlin's elementary schools (§4, Sect. 8). We can perform the
necessary calculations either directly or by R's `pbirthday`function.

```{r, echo=TRUE}
n <- 26 ; N <- 365
c(manual=1 - exp(lfactorial(365)-lfactorial(365-26) - 26*log(N)),
  pbirthday=pbirthday(n=26,classes=365))
```

Finding the `pbirthday` function as part of base R was a bit
surprising, but just underlines that R really has its roots in
statistics!

### Birthday Problem with Unequal Probabilities

```{r, READDATA, message=FALSE}
##Baby names in Berlin
filePath_onomastics <- "/Users/hoehle/Sandbox/Blog/figure/source/2017-02-06-onomastics/"
library(readr)
year <- 2016
distrNames <- read_csv(file=file.path(filePath_onomastics,paste0("berlin-firstnames-",year,".csv"))) %>% select(-strata)
distrNames <- distrNames %>% mutate(district = factor(district), sex=factor(sex))
```

In our problem $N$ corresponds to all possble names of newborns
in 2016. For the analysis we only group by firstname and thus do not
distinguish between instances of the same name applying to both
girls and boys.

```{r,echo=TRUE}
newborn <- distrNames %>% group_by(firstname) %>%
  summarise(count=sum(count)) %>% ungroup() %>%
  mutate(p=count/sum(count)) %>%
  arrange(desc(count))
```
```{r,echo=FALSE}
print(newborn, n=4)
```

In total there are $N=`r nrow(newborn)`$ possible names. From the $p$
column it also becomes obvious that not all names are equally
likely. Had they been, the quick solution to Maëlle's question would
have been:

```{r,echo=TRUE}
pbirthday(n=26, classes=nrow(newborn))
```

```{r,echo=FALSE, results='hide'}
(N <- nrow(newborn))
```
Less than `sprintf("%0.f%%",pbirthday(n=26, classes=nrow(newborn)))`!
However, we expect this probability to be much higher, if we start to
take unequal occurrence probabilities into account.

It's easy to see that the probability of no collision, i.e. no kids
having the same name, can be calculated as:
$$
P(NC_n) = n!
\underset{1\leq i_1 < i_2 < \cdots <i_n \leq r}{\sum \sum \cdots \sum}
p_{i_1} p_{i_2} \cdots p_{i_n}.
$$

However, this is a formiddable number of terms to sum. In the
case of $N=`r N`$ and $n=`r n`$ the number is:

```{r,eval=FALSE}
##noquote(sprintf("%-50.0f", choose(N,n)))
```
```{r,echo=TRUE}
Rmpfr::chooseMpfr(N,n)
```
(that's an `r floor(log10(choose(N,n)))` digit number!), which is
not *ever* going to happen. Instead @klotz1979, based on generating
functions, showed that the above corresponds to

$$
P(NC_n) = n!
\underset{\underset{\sum_{j=1}^n j \cdot t_j = r}{0\leq t_1,t_2,\ldots,<t_n \leq n}}{\sum \sum \cdots \sum}
(-1)^{n + \sum_j t_j}
\left(
\prod_{j=1}^n \frac{ (P_j/j)^{t_j}}{t_j!}
\right),
$$
where $P_j = \sum_{i=1}^N p_i^j$. The vector
$\mathbf{t}=(t_1,\ldots,t_n)$ counts the number of singletons ($t_1$),
doubletons ($t_2$), $\ldots$, up to the number of names occurring $n$
times. We now *just* have to sum over all $\mathbf{t}$ such that
$\sum_{j=1}^n j \cdot t_j = n$.

```{r}
##might be something to solve in C++ instead
make_tListFunc <- function(n) {
  str <- NULL
  str <- rbind(str, "compute_tList <- function() {")
  str <- rbind(str, "n <- ",n)
  str <- rbind(str, "tList <- NULL")
  for (i in n:1) {
    str <- rbind(str,paste0(paste0(rep(" ",n-i),collapse=""),"for (t",i," in 0:floor(n/",i,")) {"))
  }
  str <- rbind(str,paste0(paste0(rep(" ",n+1),collapse=""),paste0("t <- c(",paste0("t",1:n,collapse=","),")")))
  str <- rbind(str,paste0(paste0(rep(" ",n+1),collapse=""),"if (sum( (1:n)*t) == n) tList <- rbind(tList, t)"))
  for (i in n:1) {
    ##Sum too large, then stop summing
    str <- rbind(str,paste0(paste0(rep(" ",n+1),collapse=""),"if (sum( (n:(n-",i,"+1)*t[n:(n-",i,"+1)])) > n) break;"))

    ##Done
    str <- rbind(str, paste0(paste0(rep(" ",i-1),collapse=""),"}"))
  }
  str <- rbind(str, "return(tList)")
  str <- rbind(str, "}")
  return(str)
}

##might be something to solve in C++ instead. done! :-)
make_tListFunc_rcpp <- function(n) {
  str <- NULL
  str <- rbind(str, "#include <Rcpp.h>")
  str <- rbind(str, "// [[Rcpp::export]]")
  str <- rbind(str, 'void make_tList_rcpp() {')
  str <- rbind(str, paste0('int n = ',n,";"))
  str <- rbind(str, "std::cout << std::endl;")
  for (i in n:1) {
    str <- rbind(str,paste0(paste0(rep(" ",n-i+1),collapse=""),"for (int t",i,"=0; t",i," <= floor(n/",i,"); t",i,"++) {"))
  }

  ##Correct sum
  theSum <- paste0("(",paste0(paste0(1:n,"*t",1:n, collapse="+"),")"))
  str <- rbind(str,paste0(paste0(rep(" ",n+1),collapse=""),paste0("if (",theSum," == n) {")))
  output <- paste0("t",1:n, collapse=" << \",\" << ")
  str <- rbind(str,paste0(paste0(rep(" ",n+2),collapse=""),paste0("Rcpp::Rcout << ",output," << std::endl;")))
  str <- rbind(str,paste0(paste0(rep(" ",n+1),collapse=""),paste0("}")))

  ##Close the loops
  for (i in n:1) {
    ##Sum too large - stop
    theSum <- paste0("(",paste0(paste0(n:(n-i+1),"*t",n:(n-i+1), collapse="+"),")"))
    str <- rbind(str,paste0(paste0(rep(" ",i+1),collapse=""),paste0("if (",theSum," > n) { break; }")))

    ##Close parenthesis
    str <- rbind(str, paste0(paste0(rep(" ",i),collapse=""),"}"))
  }
  str <- rbind(str, "}")
  return(str)
}


pbirthday_up <- function(n, prob, method=c("R","Rcpp")) {
  method <- match.arg(method, c("R","Rcpp"))

  if (method == "R") {
    ##Make function to compute list of coefs
    source(textConnection(make_tListFunc(n=n)))
    ##Compute coefs
    tList <- compute_tList()
  }

  if (method == "Rcpp") {
    writeLines(make_tListFunc_rcpp(n=n),file((theCppFile = paste0(tempfile(),".cpp"))))
    Rcpp::sourceCpp(file=theCppFile)

    ##Run program and store std output to file
    theTempFile <- tempfile()
    sink(theTempFile)
    f <- make_tList_rcpp()
    sink()
    tList <- read.table(file=theTempFile,sep=",")
    if (ncol(tList) != n) { stop("Column numbers and r don't match.") }
  }

  ##Verify results
  stopifnot(rowSums(tList * matrix(1:n,ncol=n,nrow=nrow(tList),byrow=TRUE)) == n)

  ##P-symmetric funcs
  P <- sapply(seq_len(n), function(x) sum(prob^x))

  ##Might be numerical instable for large n?
  coefFun <- function(t) {
    factorial(n)*(-1)^(n+sum(t)) / prod( (1:n)^t * factorial(t))
  }

  a <- apply(tList, 1, coefFun)

  Pprod <- apply(tList, 1, function(t) prod(P^ifelse(t>0,t,0)))

  res <- list(prob=1 - sum(a * Pprod),tList=tList, P=P,a=a)
  #Result
  return(res)
}

##No so pretty
cat(paste0(paste0(make_tListFunc_rcpp(n=4),collapse="\n"),"\n"))

##Birthday problem
pbirthday_up(n=n, prob=rep(1/N, 365)
pbirthday(n=n, classes=365)


system.time(print(pbirthday_up(n=40, prob=newborn %$% p)$prob))
##60 in 3 min.
system.time(print(pbirthday_up(n=40, prob=newborn %$% p, method="Rcpp")$prob))
```

## Approximation by Mase (1992)

```{r}
######################################################################
##Approximation by Mase, p.492
######################################################################

#factorial polynomial
facpoly <- function(x, m) {
  exp(lfactorial(x) - lfactorial(x-m))
}

pbirthday_up_approx <- function(n, probs=p) {
  if (!is.integer(n)) stop("boring.")

  ##Compute S.
  S <- sapply(seq_len(r), function(x) sum(p^x))

  rho_n0 <- 1
  rho_n1 <- exp( -facpoly(r,2)/2 * S[2])
  rho_n2 <- rho_n1 * exp( facpoly(r,3) * ( -S[2]^2/2 + S[3]/3))
  rho_n3 <- rho_n2 * exp( facpoly(r,4) * ( -5/6*S[2]^3 * S[2]*S[3] - 1/4*S[4]))
  rho_n4 <- rho_n3 * exp( facpoly(r,5) * ( -7/4*S[2]^4 + 3*S[2]^2*S[3] - S[2]*S[4] + 1/5*S[5] - 1/2*S[3]^2))

  sigma <- c(1,
             sigma_n1 <- exp( -facpoly(r,2)/2 * S[2]),
             exp( facpoly(r,3) * ( -S[2]^2/2 + S[3]/3)),
             exp( facpoly(r,4) * ( -5/6*S[2]^3 * S[2]*S[3] - 1/4*S[4])),
             exp( facpoly(r,5) * ( -7/4*S[2]^4 + 3*S[2]^2*S[3] - S[2]*S[4] + 1/5*S[5] - 1/2*S[3]^2)))

  idx <- min(r,5)
  res <- cumprod(sigma)[idx]

  return(1 - res)
}

pbirthday_up_approx(n=r)
pbirthday(n=r, classes=N)


newborn %>% ungroup() %>%
  mutate(p = count/sum(count),
           ponemore = 1 - dbinom(0,size=r-1, prob=p)) %>%
  arrange(desc(count))
```
