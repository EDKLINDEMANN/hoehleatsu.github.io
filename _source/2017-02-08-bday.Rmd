---
layout: post
title: "Happy pbirthday to the class of 2016!"
tags: [rstats, stats, data journalism, onomastics]
bibliography: ~/Literature/Bibtex/jabref.bib
comments: true
---

```{r,include=FALSE,echo=FALSE,message=FALSE}
##If default fig.path, then set it.
if (knitr::opts_chunk$get("fig.path") == "figure/") {
  knitr::opts_knit$set( base.dir = '/Users/hoehle/Sandbox/Blog/')
  knitr::opts_chunk$set(fig.path="figure/source/2017-02-08-bday/")
}
fullFigPath <- paste0(knitr::opts_knit$get("base.dir"),knitr::opts_chunk$get("fig.path"))
filePath <- "/Users/hoehle/Sandbox/Blog/figure/source/2017-02-08-bday/"

knitr::opts_chunk$set(echo = TRUE,fig.width=8,fig.height=5,fig.cap='',fig.align='center',echo=FALSE) # autodep=TRUE
options(width=90)
library("dplyr")
library("ggplot2")
library("tidyr")
library("methods")
library("magrittr")

##For plotting the map
library("rgdal")
library("rgeos")

library("xtable")

##If you are unhappy about the colours, change them here
palette <- c(f="darkred",m="blue")

theme_set(theme_bw())
```

## Abstract

Continuing the last post on the analysis of firstnames given to
newborns in Berlin 2016, we are interested in the following problem:
what is the probability, that in a school class of size $n$ of these
2016 born kids there will at least two kids having the same first
name. This problem is an instance of the birthday problem with unequal
probabilities. We provide R code for brute force as well as an
approximative solution to this problem and for the case of equal
probabilities compare with R's lovely `pbirthday` function.

<center>
```{r,results='asis',echo=FALSE}
cat(paste0("![]({{ site.baseurl }}/",knitr::opts_chunk$get("fig.path"),"WORDMAPCLOUD-1.png"),")")
```
</center>

{% include license.html %}

## Introduction

In the post
[Naming Uncertainty by the Bootstrap](http://staff.math.su.se/hoehle/blog/2017/02/06/onomastics.html)
we performed a descriptive analysis of the names given to newborns in
Berlin 2016. For instance, it was shown that Marie and Alexander were
the top-1 names among girls and boys, respectively.  In a comment
[Maëlle](http://www.masalmon.eu/) asked what's the resulting
probability that there will be kids with the same name in a class.

## The Birthday Problem

Actually, this question a variation of the
[**birthday problem**](https://en.wikipedia.org/wiki/Birthday_problem),
which every statistician has solved once in an introductory
probability class: in a class of $n$ randomly chosen persons, what is
the probability that some pair of them will have the same birthday?
Assuming that there are $N=365$ possible birthdays and all days are
equally probable the answer can be calculated as: $$ P(\text{at least
two people in the class have the same birthday}) =
1-\frac{(N)_{n}}{N^n} $$ where $(x)_n = x! / (x-n)!$. Say we are
interested in $n=26$ then can perform the calculations either directly
or use the `pbirthday`function.

```{r}
n <- 26 ; N <- 365
1 - exp(lfactorial(365)-lfactorial(365-26) - 26*log(N))
pbirthday(n=26,classes=365)
```

Finding the `pbirthday` function as part of base R was a bit
surprising, but really is just a relict reminding that R really has
its roots in statistics!

### Birthday Problem with Unequal Probabilities


```{r, READDATA, message=FALSE}
##Baby names in Berlin
filePath_onomastics <- "/Users/hoehle/Sandbox/Blog/figure/source/2017-02-06-onomastics/"
library(readr)
year <- 2016
distrNames <- read_csv(file=file.path(filePath_onomastics,paste0("berlin-firstnames-",year,".csv"))) %>% select(-strata)
distrNames <- distrNames %>% mutate(district = factor(district), sex=factor(sex))
```

In our problem $N$ corresponds to all possble names in 2016.
For the analysis we only group by firstname and thus do not
distinguish between instances of the same name applying to both
females and males.

```{r,echo=TRUE}
newborn <- distrNames %>% group_by(firstname) %>%
  summarise(count=sum(count)) %>% ungroup() %>%
  mutate(p=count/sum(count)) %>%
  arrange(desc(count))
```

From the $p$ column it becomes obvious that all names are equally
likely. Had this been the case instead, the quick solution to Maëlle's
question would have been
```{r}
(N <- nrow(newborn))
pbirthday(n=26, classes=nrow(newborn))
```

We hence have to extend our analysis to the case of unequal selection
probabilities. It's easy to see that the probability of no collision,
i.e. no kids having the same name, can be calculated as:
$$
P(NC_r) = r! \underset{1\leq i_1 < i_2 <
\cdots  <i_r \leq r}{\sum \sum \cdots \sum}
p_{i_1} p_{i_2} \cdots p_{i_r}.
$$

However, this is a formiddable number of terms to investigate. In the
case of $N=`r N`$ and $n=`r n` we get that the sum consists in the
summation of:

```{r}
##noquote(sprintf("%-50.0f", choose(N,n)))
Rmpfr::chooseMpfr(N,n)
```
terms (that's an `r floor(log10(choose(N,n)))` digit number), which is
not *ever* going to happen.

```{r, BDAY}
##Prob of no repeated categories
PAr <- prod(N:(N-r+1))/N^r
1-PAr
pbirthday(n=r, classes=N)
```

```{r}
##might be something to solve in C++ instead
make_tListFunc <- function(n) {
  str <- NULL
  str <- rbind(str, "compute_tList <- function() {")
  str <- rbind(str, "n <- ",n)
  str <- rbind(str, "tList <- NULL")
  for (i in n:1) {
    str <- rbind(str,paste0(paste0(rep(" ",n-i),collapse=""),"for (t",i," in 0:floor(n/",i,")) {"))
  }
  str <- rbind(str,paste0(paste0(rep(" ",n+1),collapse=""),paste0("t <- c(",paste0("t",1:n,collapse=","),")")))
  str <- rbind(str,paste0(paste0(rep(" ",n+1),collapse=""),"if (sum( (1:n)*t) == n) tList <- rbind(tList, t)"))
  for (i in n:1) {
    ##Sum too large, then stop summing
    str <- rbind(str,paste0(paste0(rep(" ",n+1),collapse=""),"if (sum( (n:(n-",i,"+1)*t[n:(n-",i,"+1)])) > n) break;"))

    ##Done
    str <- rbind(str, paste0(paste0(rep(" ",i-1),collapse=""),"}"))
  }
  str <- rbind(str, "return(tList)")
  str <- rbind(str, "}")
  return(str)
}

##might be something to solve in C++ instead. done! :-)
make_tListFunc_rcpp <- function(n) {
  str <- NULL
  str <- rbind(str, "#include <Rcpp.h>")
  str <- rbind(str, "// [[Rcpp::export]]")
  str <- rbind(str, 'void make_tList_rcpp() {')
  str <- rbind(str, paste0('int n = ',n,";"))
  str <- rbind(str, "std::cout << std::endl;")
  for (i in n:1) {
    str <- rbind(str,paste0(paste0(rep(" ",n-i+1),collapse=""),"for (int t",i,"=0; t",i," <= floor(n/",i,"); t",i,"++) {"))
  }

  ##Correct sum
  theSum <- paste0("(",paste0(paste0(1:n,"*t",1:n, collapse="+"),")"))
  str <- rbind(str,paste0(paste0(rep(" ",n+1),collapse=""),paste0("if (",theSum," == n) {")))
  output <- paste0("t",1:n, collapse=" << \",\" << ")
  str <- rbind(str,paste0(paste0(rep(" ",n+2),collapse=""),paste0("Rcpp::Rcout << ",output," << std::endl;")))
  str <- rbind(str,paste0(paste0(rep(" ",n+1),collapse=""),paste0("}")))

  ##Close the loops
  for (i in n:1) {
    ##Sum too large - stop
    theSum <- paste0("(",paste0(paste0(n:(n-i+1),"*t",n:(n-i+1), collapse="+"),")"))
    str <- rbind(str,paste0(paste0(rep(" ",i+1),collapse=""),paste0("if (",theSum," > n) { break; }")))

    ##Close parenthesis
    str <- rbind(str, paste0(paste0(rep(" ",i),collapse=""),"}"))
  }
  str <- rbind(str, "}")
  return(str)
}


pbirthday_up <- function(n, prob, method=c("R","Rcpp")) {
  method <- match.arg(method, c("R","Rcpp"))

  if (method == "R") {
    ##Make function to compute list of coefs
    source(textConnection(make_tListFunc(n=n)))
    ##Compute coefs
    tList <- compute_tList()
  }

  if (method == "Rcpp") {
    writeLines(make_tListFunc_rcpp(n=n),file((theCppFile = paste0(tempfile(),".cpp"))))
    Rcpp::sourceCpp(file=theCppFile)

    ##Run program and store std output to file
    theTempFile <- tempfile()
    sink(theTempFile)
    f <- make_tList_rcpp()
    sink()
    tList <- read.table(file=theTempFile,sep=",")
    if (ncol(tList) != n) { stop("Column numbers and r don't match.") }
  }

  ##Verify results
  stopifnot(rowSums(tList * matrix(1:n,ncol=n,nrow=nrow(tList),byrow=TRUE)) == n)

  ##P-symmetric funcs
  P <- sapply(seq_len(n), function(x) sum(prob^x))

  ##Might be numerical instable for large n?
  coefFun <- function(t) {
    factorial(n)*(-1)^(n+sum(t)) / prod( (1:n)^t * factorial(t))
  }

  a <- apply(tList, 1, coefFun)

  Pprod <- apply(tList, 1, function(t) prod(P^ifelse(t>0,t,0)))

  res <- list(prob=1 - sum(a * Pprod),tList=tList, P=P,a=a)
  #Result
  return(res)
}

##No so pretty
cat(paste0(paste0(make_tListFunc_rcpp(n=4),collapse="\n"),"\n"))

##Birthday problem
pbirthday_up(n=n, prob=rep(1/N, 365)
pbirthday(n=n, classes=365)


system.time(print(pbirthday_up(n=40, prob=newborn %$% p)$prob))
##60 in 3 min.
system.time(print(pbirthday_up(n=60, prob=newborn %$% p, method="Rcpp")$prob))
```

## Approximation by Mase (1992)

```{r}
######################################################################
##Approximation by Mase, p.492
######################################################################

#factorial polynomial
facpoly <- function(x, m) {
  exp(lfactorial(x) - lfactorial(x-m))
}

pbirthday_up_approx <- function(n, probs=p) {
  if (!is.integer(n)) stop("boring.")

  ##Compute S.
  S <- sapply(seq_len(r), function(x) sum(p^x))

  rho_n0 <- 1
  rho_n1 <- exp( -facpoly(r,2)/2 * S[2])
  rho_n2 <- rho_n1 * exp( facpoly(r,3) * ( -S[2]^2/2 + S[3]/3))
  rho_n3 <- rho_n2 * exp( facpoly(r,4) * ( -5/6*S[2]^3 * S[2]*S[3] - 1/4*S[4]))
  rho_n4 <- rho_n3 * exp( facpoly(r,5) * ( -7/4*S[2]^4 + 3*S[2]^2*S[3] - S[2]*S[4] + 1/5*S[5] - 1/2*S[3]^2))

  sigma <- c(1,
             sigma_n1 <- exp( -facpoly(r,2)/2 * S[2]),
             exp( facpoly(r,3) * ( -S[2]^2/2 + S[3]/3)),
             exp( facpoly(r,4) * ( -5/6*S[2]^3 * S[2]*S[3] - 1/4*S[4])),
             exp( facpoly(r,5) * ( -7/4*S[2]^4 + 3*S[2]^2*S[3] - S[2]*S[4] + 1/5*S[5] - 1/2*S[3]^2)))

  idx <- min(r,5)
  res <- cumprod(sigma)[idx]

  return(1 - res)
}

pbirthday_up_approx(n=r)
pbirthday(n=r, classes=N)


newborn %>% ungroup() %>%
  mutate(p = count/sum(count),
           ponemore = 1 - dbinom(0,size=r-1, prob=p)) %>%
  arrange(desc(count))
```
